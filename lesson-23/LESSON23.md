# LESSON 23

## Задание №1

В этом задании необходимо создать класс IPAddress. При создании экземпляра класса, как аргумент передается IP-адрес и 
маска, а также должна выполняться проверка корректности адреса и маски:

* Адрес считается корректно заданным, если он:
    - состоит из 4 чисел разделенных точкой
    - каждое число в диапазоне от 0 до 255

* Маска считается корректной, если это число в диапазоне от 8 до 32 включительно

Если маска или адрес не прошли проверку, необходимо сгенерировать исключение ValueError с соответствующим текстом (вывод
ниже). Также, при создании класса, должны быть созданы две переменных экземпляра: ip и mask, в которых содержатся адрес 
и маска, соответственно. Пример создания экземпляра класса:
```python
In [1]: ip = IPAddress('10.1.1.1/24')
```
Атрибуты ip и mask:
```python
In [2]: ip1 = IPAddress('10.1.1.1/24')
In [3]: ip1.ip
Out[3]: '10.1.1.1'
In [4]: ip1.mask
Out[4]: 24
```
Проверка корректности маски (traceback сокращен)
```python
In [6]: ip1 = IPAddress('10.1.1.1/240')
---------------------------------------------------------------------------
...
ValueError: Incorrect mask
```

## Задание №2

Скопировать и изменить класс IPAddress из задания №1. Добавить два строковых представления для экземпляров 
класса IPAddress. Как должны выглядеть строковые представления, надо определить из вывода ниже:

* Создание экземпляра:
```python
In [5]: ip1 = IPAddress('10.1.1.1/24')
In [6]: str(ip1)
Out[6]: 'IP address 10.1.1.1/24'
In [7]: print(ip1)
    IP address 10.1.1.1/24
In [8]: ip1
Out[8]: IPAddress('10.1.1.1/24')
In [9]: ip_list = []
In [10]: ip_list.append(ip1)
In [11]: ip_list
Out[11]: [IPAddress('10.1.1.1/24')]
In [12]: print(ip_list)
    [IPAddress('10.1.1.1/24')]
```

## Задание №3

Скопировать класс CiscoTelnet из урока №22 задания №9 и добавить классу поддержку работы в менеджере контекста. При 
выходе из блока менеджера контекста должно закрываться соединение. Пример работы:

```python

In [14]: r1_params = {
    'ip': '192.168.100.1',
    'username': 'cisco',
    'password': 'cisco',
    'secret': 'cisco'}
In [15]: from exercise09 import CiscoTelnet
In [16]: with CiscoTelnet(**r1_params) as r1:
            print(r1.send_show_command('sh clock'))
    sh clock
    *19:17:20.244 UTC Sat Apr 6 2019
    R1#
In [17]: with CiscoTelnet(**r1_params) as r1:
            print(r1.send_show_command('sh clock'))
            raise ValueError('Возникла ошибка')

    sh clock
    *19:17:38.828 UTC Sat Apr 6 2019
    R1#
    ---------------------------------------------------------------------------
    ValueError Traceback (most recent call last)
    <ipython-input-17-f3141be7c129> in <module>
          1 with CiscoTelnet(**r1_params) as r1:
          2 print(r1.send_show_command('sh clock'))
    ----> 3 raise ValueError('Возникла ошибка')
          4
    ValueError: Возникла ошибка
```

## Задание №4

Скопировать и изменить класс Topology из урока №22 задания №5. Добавить метод, который позволит выполнять сложение двух
экземпляров класса Topology. В результате сложения должен возвращаться новый экземпляр класса Topology.
Создание двух топологий:
```python
In [1]: t1 = Topology(topology_example)
In [2]: t1.topology
Out[2]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4',  'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5',  'Eth0/0')}
In [3]: topology_example2 = {('R1', 'Eth0/4'): ('R7', 'Eth0/0'),
                             ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}
In [4]: t2 = Topology(topology_example2)
In [5]: t2.topology
Out[5]: {('R1', 'Eth0/4'): ('R7', 'Eth0/0'), ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}
```

Суммирование топологий:
```python
In [6]: t3 = t1+t2
In [7]: t3.topology
Out[7]:
  {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
   ('R1', 'Eth0/4'): ('R7', 'Eth0/0'),
   ('R1', 'Eth0/6'): ('R9', 'Eth0/0'),
   ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
   ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
   ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
   ('R3', 'Eth0/1'): ('R4', 'Eth0/0'),
   ('R3', 'Eth0/2'): ('R5', 'Eth0/0')}
```

Проверка, что исходные топологии не изменились:
```python
In [9]: t1.topology
Out[9]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4',  'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5',  'Eth0/0')}
In [10]: t2.topology
Out[10]: {('R1', 'Eth0/4'): ('R7', 'Eth0/0'), ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}
```

## Задание №5

В этом задании надо сделать так, чтобы экземпляры класса Topology были итерируемыми объектами. Основу класса Topology 
можно взять из любого задания №4. После создания экземпляра класса, экземпляр должен работать как итерируемый объект. На
каждой итерации должен возвращаться кортеж, который описывает одно соединение. Пример работы класса:

```python
In [1]: top = Topology(topology_example)
In [2]: for link in top:
            print(link)
    (('R1', 'Eth0/0'), ('SW1', 'Eth0/1'))
    (('R2', 'Eth0/0'), ('SW1', 'Eth0/2'))
    (('R2', 'Eth0/1'), ('SW2', 'Eth0/11'))
    (('R3', 'Eth0/0'), ('SW1', 'Eth0/3'))
    (('R3', 'Eth0/1'), ('R4', 'Eth0/0'))
    (('R3', 'Eth0/2'), ('R5', 'Eth0/0'))
```
Проверить работу класса.
